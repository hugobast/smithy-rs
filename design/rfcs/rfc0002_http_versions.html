<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream - AWS Rust SDK Design</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Design Overview</a></li><li class="chapter-item expanded "><a href="../tenets.html"><strong aria-hidden="true">2.</strong> Tenets</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">3.</strong> Design FAQ</a></li><li class="chapter-item expanded "><a href="../transport/overview.html"><strong aria-hidden="true">4.</strong> Transport</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../transport/operation.html"><strong aria-hidden="true">4.1.</strong> HTTP Operations</a></li><li class="chapter-item expanded "><a href="../transport/middleware.html"><strong aria-hidden="true">4.2.</strong> HTTP Middleware</a></li></ol></li><li class="chapter-item expanded "><a href="../smithy/overview.html"><strong aria-hidden="true">5.</strong> Smithy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../smithy/simple_shapes.html"><strong aria-hidden="true">5.1.</strong> Simple Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/recursive_shapes.html"><strong aria-hidden="true">5.2.</strong> Recursive Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/aggregate_shapes.html"><strong aria-hidden="true">5.3.</strong> Aggregate Shapes</a></li><li class="chapter-item expanded "><a href="../smithy/endpoint.html"><strong aria-hidden="true">5.4.</strong> Endpoint Resolution</a></li><li class="chapter-item expanded "><a href="../smithy/backwards-compat.html"><strong aria-hidden="true">5.5.</strong> Backwards Compatibility</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/overview.html"><strong aria-hidden="true">6.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/rfc0001_shared_config.html"><strong aria-hidden="true">6.1.</strong> RFC-0001: Sharing configuration between multiple clients</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0002_http_versions.html" class="active"><strong aria-hidden="true">6.2.</strong> RFC-0002: Supporting multiple HTTP versions for SDKs that use Event Stream</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0003_presigning_api.html"><strong aria-hidden="true">6.3.</strong> RFC-0003: API for Pre-signed URLs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0004_retry_behavior.html"><strong aria-hidden="true">6.4.</strong> RFC-0004: Retry Behavior</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0005_service_generation.html"><strong aria-hidden="true">6.5.</strong> RFC-0005: Smithy Rust service framework</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0006_service_specific_middleware.html"><strong aria-hidden="true">6.6.</strong> RFC-0006: Service-specific middleware</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0007_split_release_process.html"><strong aria-hidden="true">6.7.</strong> RFC-0007: Split release process</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0008_paginators.html"><strong aria-hidden="true">6.8.</strong> RFC-0008: Paginators</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0009_example_consolidation.html"><strong aria-hidden="true">6.9.</strong> RFC-0009: Example Consolidation</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0010_waiters.html"><strong aria-hidden="true">6.10.</strong> RFC-0010: Waiters</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0011_crates_io_alpha_publishing.html"><strong aria-hidden="true">6.11.</strong> RFC-0011: Publishing Alpha to Crates.io</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0012_independent_crate_versioning.html"><strong aria-hidden="true">6.12.</strong> RFC-0012: Independent Crate Versioning</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0013_body_callback_apis.html"><strong aria-hidden="true">6.13.</strong> RFC-0013: Body Callback APIs</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0014_timeout_config.html"><strong aria-hidden="true">6.14.</strong> RFC-0014: Fine-grained timeout configuration</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0015_using_features_responsibly.html"><strong aria-hidden="true">6.15.</strong> RFC-0015: How Cargo "features" should be used in the SDK and runtime crates</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0016_flexible_checksum_support.html"><strong aria-hidden="true">6.16.</strong> RFC-0016: Supporting Flexible Checksums</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0017_customizable_client_operations.html"><strong aria-hidden="true">6.17.</strong> RFC-0017: Customizable Client Operations</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0018_logging_sensitive.html"><strong aria-hidden="true">6.18.</strong> RFC-0018: Logging in the Presence of Sensitive Data</a></li><li class="chapter-item expanded "><a href="../rfcs/rfc0019_event_streams_errors.html"><strong aria-hidden="true">6.19.</strong> RFC-0019: Event Streams Errors</a></li></ol></li><li class="chapter-item expanded "><a href="../contributing/overview.html"><strong aria-hidden="true">7.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../contributing/writing_and_debugging_a_low-level_feature_that_relies_on_HTTP.html"><strong aria-hidden="true">7.1.</strong> Writing and debugging a low-level feature that relies on HTTP</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AWS Rust SDK Design</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rfc-supporting-multiple-http-versions-for-sdks-that-use-event-stream"><a class="header" href="#rfc-supporting-multiple-http-versions-for-sdks-that-use-event-stream">RFC: Supporting multiple HTTP versions for SDKs that use Event Stream</a></h1>
<blockquote>
<p>Status: Accepted</p>
</blockquote>
<p>For a summarized list of proposed changes, see the <a href="#changes-checklist">Changes Checklist</a> section.</p>
<p>Most AWS SDK operations use HTTP/1.1, but bi-directional streaming operations that use the Event Stream
message framing format need to use HTTP/2 (h2).</p>
<p>Smithy models can also customize which HTTP versions are used in each individual protocol trait.
For example,
<a href="https://awslabs.github.io/smithy/1.0/spec/aws/aws-restjson1-protocol.html#aws-protocols-restjson1-trait"><code>@restJson1</code> has attributes <code>http</code> and <code>eventStreamHttp</code></a>
to list out the versions that should be used in a priority order.</p>
<p>There are two problems in play that this doc attempts to solve:</p>
<ol>
<li><strong>Connector Creation</strong>: Customers need to be able to create connectors with the HTTP settings they desire,
and these custom connectors must align with what the Smithy model requires.</li>
<li><strong>Connector Selection</strong>: The generated code must be able to select the connector that best matches the requirements
from the Smithy model.</li>
</ol>
<h2 id="terminology"><a class="header" href="#terminology">Terminology</a></h2>
<p>Today, there are three layers of <code>Client</code> that are easy to confuse, so to make the following easier to follow,
the following terms will be used:</p>
<ul>
<li><strong>Connector</strong>: An implementor of Tower's <code>Service</code> trait that converts a request into a response. This is typically
a thin wrapper around a Hyper client.</li>
<li><strong>Smithy Client</strong>: A <code>aws_smithy_client::Client&lt;C, M, R&gt;</code> struct that is responsible for gluing together
the connector, middleware, and retry policy. This isn't intended to be used directly.</li>
<li><strong>Fluent Client</strong>: A code generated <code>Client&lt;C, M, R&gt;</code> that has methods for each service operation on it.
A fluent builder is generated alongside it to make construction easier.</li>
<li><strong>AWS Client</strong>: A specialized Fluent Client that uses a <code>DynConnector</code>, <code>DefaultMiddleware</code>,
and <code>Standard</code> retry policy.</li>
</ul>
<p>All of these are just called <code>Client</code> in code today. This is something that could be clarified in a separate refactor.</p>
<h2 id="how-clients-work-today"><a class="header" href="#how-clients-work-today">How Clients Work Today</a></h2>
<p>Fluent clients currently keep a handle to a single Smithy client, which is a wrapper
around the underlying connector. When constructing operation builders, this handle is <code>Arc</code> cloned and
given to the new builder instances so that their <code>send()</code> calls can initiate a request.</p>
<p>The generated fluent client code ends up looking like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Handle&lt;C, M, R&gt; {
    client: aws_smithy_client::Client&lt;C, M, R&gt;,
    conf: crate::Config,
}

pub struct Client&lt;C, M, R = Standard&gt; {
    handle: Arc&lt;Handle&lt;C, M, R&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Functions are generated per operation on the fluent client to gain access to the individual operation builders.
For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn assume_role(&amp;self) -&gt; fluent_builders::AssumeRole&lt;C, M, R&gt; {
    fluent_builders::AssumeRole::new(self.handle.clone())
}
<span class="boring">}
</span></code></pre></pre>
<p>The fluent operation builders ultimately implement <code>send()</code>, which chooses the one and only Smithy client out
of the handle to make the request with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AssumeRole&lt;C, M, R&gt; {
    handle: std::sync::Arc&lt;super::Handle&lt;C, M, R&gt;&gt;,
    inner: crate::input::assume_role_input::Builder,
}

impl&lt;C, M, R&gt; AssumeRole&lt;C, M, R&gt; where ...{
    pub async fn send(self) -&gt; Result&lt;AssumeRoleOutput, SdkError&lt;AssumeRoleError&gt;&gt; where ... {
        // Setup code omitted ...

        // Make the actual request
        self.handle.client.call(op).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Smithy clients are constructed from a connector, as shown:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connector = Builder::new()
    .https()
    .middleware(...)
    .build();
let client = Client::with_config(connector, Config::builder().build());
<span class="boring">}
</span></code></pre></pre>
<p>The <code>https()</code> method on the Builder constructs the actual Hyper client, and is driven off Cargo features to
select the correct TLS implementation. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;rustls&quot;)]
pub fn https() -&gt; Https {
    let https = hyper_rustls::HttpsConnector::with_native_roots();
    let client = hyper::Client::builder().build::&lt;_, SdkBody&gt;(https);
    // HyperAdapter is a Tower `Service` request -&gt; response connector that just calls the Hyper client
    crate::hyper_impls::HyperAdapter::from(client)
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="solving-the-connector-creation-problem"><a class="header" href="#solving-the-connector-creation-problem">Solving the Connector Creation Problem</a></h2>
<p>Customers need to be able to provide HTTP settings, such as timeouts, for all connectors that the clients use.
These should come out of the <code>SharedConfig</code> when it is used. Connector creation also needs to be customizable
so that alternate HTTP implementations can be used, or so that a fake implementation can be used for tests.</p>
<p>To accomplish this, <code>SharedConfig</code> will have a <code>make_connector</code> member. A customer would configure
it as such:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let config = some_shared_config_loader()
    .with_http_settings(my_http_settings)
    .with_make_connector(|reqs: &amp;MakeConnectorRequirements| {
        Some(MyCustomConnector::new(reqs))
    })
    .await;
<span class="boring">}
</span></code></pre></pre>
<p>The passed in <code>MakeConnectorRequirements</code> will hold the customer-provided <code>HttpSettings</code> as well
as any Smithy-modeled requirements, which will just be <code>HttpVersion</code> for now. The <code>MakeConnectorRequirements</code>
struct will be marked <code>non_exhaustive</code> so that new requirements can be added to it as the SDK evolves.</p>
<p>A default <code>make_connector</code> implementation would be provided that creates a Hyper connector based on the
Cargo feature flags. This might look something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;rustls&quot;)]
pub fn default_connector(reqs: &amp;HttpRequirements) -&gt; HyperAdapter {
    let https = hyper_rustls::HttpsConnector::with_native_roots();
    let mut builder = hyper::Client::builder();
    builder = configure_settings(builder, &amp;reqs.http_settings);
    if let Http2 = &amp;reqs.http_version {
        builder = builder.http2_only(true);
    }
    HyperAdapter::from(builder.build::&lt;_, SdkBody&gt;(https))
}
<span class="boring">}
</span></code></pre></pre>
<p>For any given service, <code>make_connector</code> could be called multiple times to create connectors
for all required HTTP versions and settings.</p>
<p><strong>Note:</strong> the <code>make_connector</code> returns an <code>Option</code> since an HTTP version may not be required, but rather, preferred
according to a Smithy model. For operations that list out <code>[&quot;h2&quot;, &quot;HTTP/1.1&quot;]</code> as the desired versions,
a customer could choose to provide only an HTTP 1 connector, and the operation should still succeed.</p>
<h2 id="solving-the-connector-selection-problem"><a class="header" href="#solving-the-connector-selection-problem">Solving the Connector Selection Problem</a></h2>
<p>Each service operation needs to be able to select a connector that meets its requirements best
from the customer provided connectors. Initially, the only selection criteria will be the HTTP version,
but later when per-operation HTTP settings are implemented, the connector will also need to be keyed off of those
settings. Since connector creation is not a cheap process, connectors will need to be cached after they are
created.</p>
<p>This caching is currently handled by the <code>Handle</code> in the fluent client, which holds on to the
Smithy client. This cache needs to be adjusted to:</p>
<ul>
<li>Support multiple connectors, keyed off of the customer provided <code>HttpSettings</code>, and also off of the Smithy modeled requirements.</li>
<li>Be lazy initialized. Services that have a mix of Event Stream and non-streaming operations shouldn't create
an HTTP/2 client if the customer doesn't intend to use the Event Stream operations that require it.</li>
</ul>
<p>To accomplish this, the <code>Handle</code> will hold a cache that is optimized for many reads and few writes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Hash, Eq, PartialEq)]
struct ConnectorKey {
    http_settings: HttpSettings,
    http_version: HttpVersion,
}

struct Handle&lt;C, M, R&gt; {
    clients: RwLock&lt;HashMap&lt;HttpRequirements&lt;'static&gt;, aws_smithy_client::Client&lt;C, M, R&gt;&gt;&gt;,
    conf: crate::Config,
}

pub struct Client&lt;C, M, R = Standard&gt; {
    handle: Arc&lt;Handle&lt;C, M, R&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>With how the generics are organized, the connector type will have to be the same between HTTP implementations,
but this should be fine since it is generally a thin wrapper around a separate HTTP implementor.
For cases where it is not, the custom connector type can host its own <code>dyn Trait</code> solution.</p>
<p>The <code>HttpRequirements</code> struct will hold <code>HttpSettings</code> as copy-on-write so that it can be used
for cache lookup without having to clone <code>HttpSettings</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct HttpRequirements&lt;'a&gt; {
    http_settings: Cow&lt;'a, HttpSettings&gt;,
    http_version: HttpVersion,
}

impl&lt;'a&gt; HttpRequirements&lt;'a&gt; {
    // Needed for converting a borrowed HttpRequirements into an owned cache key for cache population
    pub fn into_owned(self) -&gt; HttpRequirements&lt;'static&gt; {
        Self {
            http_settings: Cow::Owned(self.http_settings.into_owned()),
            http_version: self.http_version,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With the cache established, each operation needs to be aware of its requirements. The code generator will be
updated to store a prioritized list of <code>HttpVersion</code> in the property bag in an input's <code>make_operation()</code> method.
This prioritized list will come from the Smithy protocol trait's <code>http</code> or <code>eventStreamHttp</code> attribute, depending
on the operation. The fluent client will then pull this list out of the property bag so that it can determine which
connector to use. This indirection is necessary so that an operation still holds all information
needed to make a service call from the Smithy client directly.</p>
<p><strong>Note:</strong> This may be extended in the future to be more than just <code>HttpVersion</code>, for example, when per-operation
HTTP setting overrides are implemented. This doc is not attempting to solve that problem.</p>
<p>In the fluent client, this will look as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;C, M, R&gt; AssumeRole&lt;C, M, R&gt; where ... {
    pub async fn send(self) -&gt; Result&lt;AssumeRoleOutput, SdkError&lt;AssumeRoleError&gt;&gt; where ... {
        let input = self.create_input()?;
        let op = input.make_operation(&amp;self.handle.conf)?;

        // Grab the `make_connector` implementation
        let make_connector = self.config.make_connector();

        // Acquire the prioritized HttpVersion list
        let http_versions = op.properties().get::&lt;HttpVersionList&gt;();

        // Make the actual request (using default HttpSettings until modifying those is implemented)
        let client = self.handle
            .get_or_create_client(make_connector, &amp;default_http_settings(), &amp;http_versions)
            .await?;
        client.call(op).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If an operation requires a specific protocol version, and if the <code>make_connection</code> implementation can't
provide that it, then the <code>get_or_create_client()</code> function will return <code>SdkError::ConstructionFailure</code>
indicating the error.</p>
<h2 id="changes-checklist"><a class="header" href="#changes-checklist">Changes Checklist</a></h2>
<ul>
<li><input disabled="" type="checkbox"/>
Create <code>HttpVersion</code> in <code>aws-smithy-http</code> with <code>Http1_1</code> and <code>Http2</code></li>
<li><input disabled="" type="checkbox"/>
Refactor existing <code>https()</code> connector creation functions to take <code>HttpVersion</code></li>
<li><input disabled="" type="checkbox"/>
Add <code>make_connector</code> to <code>SharedConfig</code>, and wire up the <code>https()</code> functions as a default</li>
<li><input disabled="" type="checkbox"/>
Create <code>HttpRequirements</code> in <code>aws-smithy-http</code></li>
<li><input disabled="" type="checkbox"/>
Implement the connector cache on <code>Handle</code></li>
<li><input disabled="" type="checkbox"/>
Implement function to calculate a minimum required set of HTTP versions from a Smithy model in the code generator</li>
<li><input disabled="" type="checkbox"/>
Update the <code>make_operation</code> code gen to put an <code>HttpVersionList</code> into the operation property bag</li>
<li><input disabled="" type="checkbox"/>
Update the fluent client <code>send()</code> function code gen grab the HTTP version list and acquire the correct connector with it</li>
<li><input disabled="" type="checkbox"/>
Add required defaulting for models that don't set the optional <code>http</code> and <code>eventStreamHttp</code> protocol trait attributes</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rfcs/rfc0001_shared_config.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../rfcs/rfc0003_presigning_api.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rfcs/rfc0001_shared_config.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../rfcs/rfc0003_presigning_api.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../static/mermaid.min.js"></script>
        <script type="text/javascript" src="../static/mermaid-init.js"></script>


    </body>
</html>
